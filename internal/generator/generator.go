package generator

import (
	"fmt"
	"strconv"
	"text/template"

	"google.golang.org/genproto/googleapis/api/annotations"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
)

func Generate(plugin *protogen.Plugin) error {
	reg := registry{
		resources: nil,
		byType:    map[resourceType]int{},
		byFile:    map[*protogen.File][]int{},
	}

	for _, f := range plugin.Files {
		if err := walkFile(&reg, f); err != nil {
			return err
		}
	}

	for f, is := range reg.byFile {
		if !f.Generate {
			continue
		}

		g := plugin.NewGeneratedFile(f.GeneratedFilenamePrefix+".pb.resource.go", f.GoImportPath)

		if err := headerTmpl.Execute(g, f.GoPackageName); err != nil {
			return err
		}

		for _, i := range is {
			if err := generateResource(g, reg.resources[i]); err != nil {
				return err
			}
		}

		if err := generateFileRefs(&reg, g, f); err != nil {
			return err
		}
	}

	return nil
}

type registry struct {
	resources []*resource
	byType    map[resourceType]int
	byFile    map[*protogen.File][]int
}

func (reg *registry) insert(f *protogen.File, r *resource) {
	reg.resources = append(reg.resources, r)
	reg.byType[r.Type] = len(reg.resources) - 1
	reg.byFile[f] = append(reg.byFile[f], len(reg.resources)-1)
}

func walkFile(reg *registry, f *protogen.File) error {
	fileResources, err := newFileResources(f)
	if err != nil {
		return fmt.Errorf("generate file resource: %s: %w", f.GoImportPath, err)
	}

	for _, r := range fileResources {
		reg.insert(f, r)
	}

	for _, m := range f.Messages {
		if err := walkMessage(reg, f, m); err != nil {
			return err
		}
	}

	return nil
}

func walkMessage(reg *registry, f *protogen.File, m *protogen.Message) error {
	for _, m := range m.Messages {
		if err := walkMessage(reg, f, m); err != nil {
			return err
		}
	}

	r, err := newMessageResource(m)
	if err != nil {
		return fmt.Errorf("generate message resource: %s: %w", m.GoIdent, m)
	}

	// r being nil indicates there is no resource for the message, and so we
	// just skip the message.
	if r != nil {
		reg.insert(f, r)
	}

	return nil
}

var headerTmpl = template.Must(template.New("header").Parse(`
// Code generated by protoc-gen-go-resource. DO NOT EDIT.
package {{ . }}

import (
	"fmt"
	"strings"
)
`))

var parserTmpl = template.Must(template.New("resource").Parse(`
type {{ .TypeName }} struct {
{{ range $s := .Pattern }}
	{{ if $s.Var }}
	{{ $s.FieldName }} string
	{{ end }}
{{ end }}
}

func {{ .FuncName }}(s string) ({{ .TypeName }}, error) {
	p := strings.Split(s, "/")
	if len(p) != {{ len .Pattern }} {
		return {{ .TypeName }}{}, fmt.Errorf("parse %q: bad number of segments, want: {{ len .Pattern }}, got: %d", s, len(p))
	}

	var out {{ .TypeName }}
{{ $t := .TypeName }}
{{ range $i, $s := .Pattern }}
	{{ if $s.Var }}
	out.{{ $s.FieldName }} = p[{{ $i }}]
	{{ else }}
	if p[{{ $i }}] != {{ printf "%q" $s.Name }} {
		return {{ $t }}{}, fmt.Errorf("parse %q: bad segment {{ $i }}, want: %q, got: %q", s, {{ printf "%q" $s.Name }}, p[{{ $i }}])
	}
	{{ end }}
{{ end }}
	return out, nil
}

func {{ .FullFuncName }}(s string) ({{ .TypeName }}, error) {
	if !strings.HasPrefix(s, {{ .ServicePrefix | printf "%q" }}) {
		return {{ .TypeName }}{}, fmt.Errorf("parse %q: invalid prefix, want: %q", s, {{ .ServicePrefix | printf "%q" }})
	}

	return {{ .FuncName }}(strings.TrimPrefix(s, {{ .ServicePrefix | printf "%q" }}))
}

func (n {{ .TypeName }}) Name() string {
	var out string
{{ range $i, $s := .Pattern }}
	{{ if $i }}
	out += "/"
	{{ end }}
	{{ if $s.Var }}
	out += n.{{ $s.FieldName }}
	{{ else }}
	out += {{ printf "%q" $s.Name }}
	{{ end }}
{{ end }}
	return out
}

func (n {{ .TypeName }}) FullName() string {
	return {{ .ServicePrefix | printf "%q" }} + n.Name()
}

{{ if .EmbedFuncName }}
func (n {{ .TypeName }}) {{ .EmbedFuncName }}() {}
{{ end }}
`))

type parserData struct {
	TypeName               string
	ServicePrefix          string
	FuncName, FullFuncName string
	EmbedFuncName          string
	Pattern                pattern
}

var multiPatternInterfaceTmpl = template.Must(template.New("multi_pattern_interface").Parse(`
type {{ .TypeName }} interface {
	Name() string
	FullName() string
	{{ .EmbedFuncName }}()
}

func {{ .FuncName }}(s string) ({{ .TypeName }}, error) {
	var errs []string
	var res {{ .TypeName }}
	var err error
{{ range $i, $f := .ImplFuncNames }}
	res, err = {{ $f }}(s)
	if err == nil {
		return res, nil
	}

	errs = append(errs, fmt.Sprintf("pattern {{ $i }}: %v", err))
{{ end }}

	return nil, fmt.Errorf("no pattern matches input: %v", strings.Join(errs, "; "))
}

func {{ .FullFuncName }}(s string) ({{ .TypeName }}, error) {
	if !strings.HasPrefix(s, {{ .ServicePrefix | printf "%q" }}) {
		return nil, fmt.Errorf("parse %q: invalid prefix, want: %q", s, {{ .ServicePrefix | printf "%q" }})
	}

	return {{ .FuncName }}(strings.TrimPrefix(s, {{ .ServicePrefix | printf "%q" }}))
}
`))

type multiPatternInterfaceData struct {
	TypeName               string
	FuncName, FullFuncName string
	ServicePrefix          string
	EmbedFuncName          string
	ImplFuncNames          []string
}

func generateResource(g *protogen.GeneratedFile, r *resource) error {
	servicePrefix := "//" + r.Type.ServiceName + "/"

	if len(r.Patterns) == 1 {
		if err := parserTmpl.Execute(g, parserData{
			TypeName:      r.ParsedType.GoName,
			ServicePrefix: servicePrefix,
			FuncName:      r.ParseFunc.GoName,
			FullFuncName:  r.FullParseFunc.GoName,
			Pattern:       r.Patterns[0],
		}); err != nil {
			return err
		}

		return nil
	}

	embedFuncName := "mustEmbed" + r.ParsedType.GoName

	var implFuncNames []string
	for i, p := range r.Patterns {
		typeName := r.ParsedType.GoName + "_" + strconv.Itoa(i)
		funcName := r.ParseFunc.GoName + "_" + strconv.Itoa(i)
		fullFuncName := r.ParseFunc.GoName + "Full_" + strconv.Itoa(i)
		if err := parserTmpl.Execute(g, parserData{
			TypeName:      typeName,
			ServicePrefix: servicePrefix,
			FuncName:      funcName,
			FullFuncName:  fullFuncName,
			Pattern:       p,
			EmbedFuncName: embedFuncName,
		}); err != nil {
			return err
		}

		implFuncNames = append(implFuncNames, funcName)
	}

	if err := multiPatternInterfaceTmpl.Execute(g,
		multiPatternInterfaceData{
			TypeName:      r.ParsedType.GoName,
			FuncName:      r.ParseFunc.GoName,
			FullFuncName:  r.FullParseFunc.GoName,
			ServicePrefix: servicePrefix,
			EmbedFuncName: embedFuncName,
			ImplFuncNames: implFuncNames,
		}); err != nil {
		return err
	}

	return nil
}

var referenceTmpl = template.Must(template.New("reference").Parse(`
func (x *{{ .ReferrerTypeName }}) {{ .ReferenceFuncName }}() ({{ .ReferentTypeName }}, error) {
	return {{ .ReferentFuncName }}(x.{{ .ReferrerFieldName }})
}
`))

type referenceData struct {
	ReferrerTypeName  string
	ReferrerFieldName string
	ReferenceFuncName string
	ReferentTypeName  string
	ReferentFuncName  string
}

func generateFileRefs(reg *registry, g *protogen.GeneratedFile, f *protogen.File) error {
	for _, m := range f.Messages {
		if err := generateMessageRefs(reg, g, m); err != nil {
			return err
		}
	}

	return nil
}

func generateMessageRefs(reg *registry, g *protogen.GeneratedFile, m *protogen.Message) error {
	for _, m := range m.Messages {
		if err := generateMessageRefs(reg, g, m); err != nil {
			return err
		}
	}

	res, err := newMessageResource(m)
	if err != nil {
		return err
	}

	if res != nil {
		if err := referenceTmpl.Execute(g, referenceData{
			ReferrerTypeName:  g.QualifiedGoIdent(m.GoIdent),
			ReferrerFieldName: res.NameField.GoName,
			ReferenceFuncName: "Parse" + res.NameField.GoName,
			ReferentTypeName:  g.QualifiedGoIdent(res.ParsedType),
			ReferentFuncName:  g.QualifiedGoIdent(res.ParseFunc),
		}); err != nil {
			return err
		}
	}

	for _, f := range m.Fields {
		o := f.Desc.Options().(*descriptorpb.FieldOptions)
		rr := proto.GetExtension(o, annotations.E_ResourceReference).(*annotations.ResourceReference)
		if rr == nil {
			continue
		}

		// Ignore fields that don't set "type", or have it set to the special
		// wildcard value.
		if rr.Type == "" || rr.Type == "*" {
			continue
		}

		resType, err := newResourceType(rr.Type)
		if err != nil {
			return fmt.Errorf("parse resource reference: %s: %w", f.GoIdent, err)
		}

		refResIndex, ok := reg.byType[resType]
		if !ok {
			return fmt.Errorf("reference to unknown type: %q", rr.Type)
		}

		refRes := reg.resources[refResIndex]

		if err := referenceTmpl.Execute(g, referenceData{
			ReferrerTypeName:  g.QualifiedGoIdent(m.GoIdent),
			ReferrerFieldName: f.GoName,
			ReferenceFuncName: "Parse" + f.GoName,
			ReferentTypeName:  g.QualifiedGoIdent(refRes.ParsedType),
			ReferentFuncName:  g.QualifiedGoIdent(refRes.ParseFunc),
		}); err != nil {
			return err
		}
	}

	return nil
}
